{
  "hash": "706c5aa323175922dcb5dea673405f0f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Python patterns: single dispatch vs adaptors\"\nauthor: Michael Chow\ndate: '2024-07-12'\nslug: dispatch-vs-adaptors\nfreeze: true\n---\n\n\n\nOften, library developers need to perform the same set of actions over classes from different libraries. For example, a person might want their library to be able to handle DataFrames from both the Pandas and Polars libraries.\n\nIn general there are two common approaches to this:\n\n* **adapters**: create new data (i.e. a class) in order to perform new actions\n* **single dispatch**: create new actions (i.e. functions) directly for existing data\n\nIn my experience, adapters seem to be the most common. Often, when implementing single dispatch, people will ask why I am not using an adapter.  This post is an attempt to explain why: adapters are a special case of single dispatch, with a tricky layer of data added.\n\n> (What I am calling single dispatch here is single [generic function](https://peps.python.org/pep-0443) dispatch.)\n\n\n## The challenge: define new actions over DataFrames\n\nSuppose you are building a data tool in python, and want to be able support both Pandas and Polars DataFrames.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport polars as pl\n\ndf_pandas = pd.DataFrame({\"x\": [1, 2], \"y\": [3, 4]})\ndf_polars = pl.from_pandas(df_pandas)\n```\n:::\n\n\nThese two types of DataFrames have many similarities, but also a devilish number of tiny differences.\n\nFor example, both have a `.columns` property that reports similar information (column names), but they each return different types of things.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndf_pandas.columns  # a pd.Index object\ndf_polars.columns  # a list of strings\n```\n\n::: {.cell-output .cell-output-display execution_count=266}\n```\n['x', 'y']\n```\n:::\n:::\n\n\nIn practice, it's not hard to turn both results into a list, but some layer of logic is needed to handle operating on either type of DataFrame.\n\n## Adapters: new classes with new actions (methods)\n\nA common approach in Python is to use the adapter pattern.\nAdapters are classes that wrap the data, with methods for performing new actions on that data.\n\nFor example, you could create a `.columns()` method to return the column names of either DataFrame as a list.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nclass PandasAdapter:\n    def __init__(self, data: pd.DataFrame):\n        self._d = data\n\n    def columns(self) -> list[str]:\n        # must make columns a list\n        return list(self._d.columns)\n\n\nclass PolarsAdapter:\n    def __init__(self, data: pl.DataFrame):\n        self._d = data\n\n    def columns(self) -> list[str]:\n        # similar to pandas, but columns already a list\n        return self._d.columns\n\n\npd_adapter = PandasAdapter(df_pandas)\npl_adapter = PolarsAdapter(df_polars)\n\n# both return [\"x\", \"y\"]\npd_adapter.columns()\npl_adapter.columns()\n```\n\n::: {.cell-output .cell-output-display execution_count=267}\n```\n['x', 'y']\n```\n:::\n:::\n\n\n### Dilemma 1: actions that produce DataFrames\n\nOne challenge with adapters is that you need to keep wrapping the original data. For example, if you wanted to add a `subset_rows()` method---which creates a new DataFrame with fewer rows---that new DataFrame result will need to be wrapped in an adaptor.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nfrom typing_extensions import Self\n\n\nclass PandasAdapter:\n    ...\n\n    def subset_rows(self, rows: list[int]) -> Self:\n        return self.__class__(self._d.iloc[rows])\n\n\nclass PolarsAdapter:\n    ...\n\n    def subset_rows(self, rows: list[int]) -> Self:\n        return self.__class__(self._d[rows])\n\n```\n:::\n\n\n\n\nNow that `.subset_rows()` returns an adaptor, you can use the `.columns()` method on it.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nPandasAdapter(df_pandas).subset_rows([1]).columns()\n```\n\n::: {.cell-output .cell-output-display execution_count=270}\n```\n['x', 'y']\n```\n:::\n:::\n\n\nThis is fine, but quickly spirals out of control:\n\n* **Adapting DataFrame parts**: each column of a DataFrame is a series. If you want to adapt the Series, now you need to return a `PolarsSeriesAdapter`, etc..\n* **Adapting adaptors**: notice how we used DataFrame methods in our adaptor code. If someone wanted to use DataFrame methods and your adaptor methods, it quickly becomes a nightmare.\n\nThe second piece is a nightmare worth talking about.\n\n### Dilemma 2: adapters of adapters of adapters\n\nSuppose 2 libraries wrote DataFrame adapters. In order use them, you would basically have to juggle..\n\n* wrapping the data in adaptor1 to call its methods.\n* unwrapping the data\n* wrapping the data in adaptor2 to call its methods.\n\nThis feels wrong because adapters don't functionally add any new data. They appear as new data in order to create new actions.\n\n## Single dispatch: new actions only\n\nBy contrast, generic functions do what adapters do (add new actions), but are just regular functions. The most common form of generic function dispatch is single dispatch, where the first argument to a function is used to determine which implementation to use.\n\nFor example, here is the `.columns()` method reimplemented using python's built in `singledispatch` decorator.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nfrom functools import singledispatch\n\n# columns ----\n\n\n@singledispatch\ndef columns(data):\n    raise TypeError(f\"Unsupported type: {type(data)}\")\n\n\n@columns.register\ndef _(data: pd.DataFrame) -> list[str]:\n    return list(data.columns)\n\n\n@columns.register\ndef _(data: pl.DataFrame) -> list[str]:\n    return data.columns\n\n\ncolumns(df_pandas)\ncolumns(df_polars)\n```\n\n::: {.cell-output .cell-output-display execution_count=271}\n```\n['x', 'y']\n```\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n@singledispatch\ndef subset_rows(data, rows: list[int]):\n    raise TypeError(f\"Unsupported type: {type(data)}\")\n\n\n@subset_rows.register\ndef _(data: pd.DataFrame, rows: list[int]) -> pd.DataFrame:\n    return data.iloc[rows]\n\n\n@subset_rows.register\ndef _(data: pl.DataFrame, rows: list[int]) -> pl.DataFrame:\n    return data[rows]\n```\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ncolumns(subset_rows(df_pandas, [1]))\n```\n\n::: {.cell-output .cell-output-display execution_count=273}\n```\n['x', 'y']\n```\n:::\n:::\n\n\n### You can still create adapters with singledispatch\n\nThere's an exciting twist: adaptors are a special case of single dispatch.\n\nRecall that..\n\n* singledispatch creates new actions on existing classes\n* an adaptor creates a new class (in order to create new actions)\n\nAdapters are single dispatch over a new class. More specifically, they are what's called generic method dispatch, since the first argument (`self`) is the class that determines the specific method to call (e.g. `PandasAdapter.columns()` vs `PolarsAdapter.columns()`).\n\nIt's quick for single dispatch (using generic functions) to implement the same actions an adaptor might have. For example, here is `columns()` re-implemented over the `PandasAdapter`.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n@columns.register\ndef _(data: PandasAdapter) -> list[str]:\n    return list(data._d.columns)\n\n\n@subset_rows.register\ndef _(data: PandasAdapter, rows: list[int]) -> PandasAdapter:\n    return data._d.iloc[rows]\n\n\ncolumns(subset_rows(PandasAdapter(df_pandas), [1]))\n```\n\n::: {.cell-output .cell-output-display execution_count=274}\n```\n['x', 'y']\n```\n:::\n:::\n\n\nThe big difference between adaptors and singledispatch is that you can't go the other way: Python's singledispatch can do what adaptors do, but adaptors can't restirct themselves to what singledispatch does (since they do something extra--create a new piece of class data).\n\nTo really drive this point home, the code below registers the adaptor methods directly to a new single dispatch function, `subset_rows2()`:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n@singledispatch\ndef subset_rows2(data, rows):\n    raise TypeError()\n\n\nsubset_rows2.register(PandasAdapter, PandasAdapter.subset_rows)\nsubset_rows2.register(PolarsAdapter, PolarsAdapter.subset_rows)\n\nsubset_rows2(PandasAdapter(df_pandas), [1])\n```\n\n::: {.cell-output .cell-output-display execution_count=275}\n```\n<__main__.PandasAdapter at 0x1534f0130>\n```\n:::\n:::\n\n\nNote that the big challenge is there's no way to undo the wrapping: whereas the single dispatch functions were written to operate on DataFrames directly, the adaptor methods expect a DataFrame wrapped in something.\n\nAnother way to say this is that the single dispatch functions could be DataFrame methods if they wanted to be:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\npd.DataFrame.subset_rows = subset_rows\n\ndf_pandas.subset_rows([1])\n```\n\n::: {.cell-output .cell-output-display execution_count=276}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>x</th>\n      <th>y</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>4</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Should I never use adaptors?\n\nAdapters in Python have one big benefit: they can use [method chaining](https://stackoverflow.com/a/41817688). For user-facing interaces this can be really helpful! Often when people ask about adaptors though, they're using them for back-of-shop activities. In this case, I think adaptors are less useful.\n\nAnother useful place for an adapter is when it needs to hold data. For example, if `PandasAdapter` needed to hold options, or state. In this case, you could still use `singledispatch` to separate `PandasAdapter` data (e.g. its options and state) from its actions (e.g. the singledispatch functions that operate on it).\n\nFinally, many programming decisions are social in nature. If people are more likely to use (or contribute to) an adapter, then it makes sense to use one.\n\n## Wrapping up\n\nAdapters and single (generic function) dispatch are two ways to add new actions to existing data. While single dispatch gets away with implementing functions directly, adaptors add a new type of data: a class wrapping the original data.\n\nFor more on the joys and challenges of single (generic function) dispatch, see:\n\n* [databackend](https://github.com/machow/databackend): a library for using singledispatch with optional dependencies.\n* [Single dispatch for democratizing data science tools](https://mchow.com/posts/2020-02-24-single-dispatch-data-science/): more on single dispatch.\n* [python docs on singledispatch](https://docs.python.org/3/library/functools.html#functools.singledispatch)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}